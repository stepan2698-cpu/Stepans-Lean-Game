msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-12\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Induction.Addition
msgid "0 + a = a"
msgstr ""

#: Game.Implication.predecessor
msgid "If succ(a) = succ(b), then a = b"
msgstr ""

#: Game.Implication.Cancellation
#: Game
msgid ""
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `intro h`
#. ยง2: `Q`
#. ยง3: `h : P`
#. ยง4: `h`
#: Game.Implication.implication
msgid "To prove the goal of type ยง0, you need to mimic the 'Assume P. Then Q' structure in\n"
"the natural language proof. You can do that by typing ยง1. This will change the goal\n"
"to ยง2 and add ยง3 to the list of your assumptions. Here ยง4 is just an arbitrary name\n"
"you can give ti the assumption."
msgstr ""

#. ยง0: `exact`
#. ยง1: `exact`
#. ยง2: `exact h1`
#: Game.Implication.implication
msgid "Another way to use assumptions is the ยง0 command. If your goal is the same as one\n"
"of your assumptions, you can use the ยง1 command to finish the proof. For example,\n"
"you can type ยง2 in the example below."
msgstr ""

#: Game.Induction.Multiplication
msgid "a * (b + c) = a * b + a * c"
msgstr ""

#: Game.Implication.predecessor
msgid "is_zero zero"
msgstr ""

#: Game.Induction.Multiplication
msgid "Right-commutativity of multiplication"
msgstr ""

#: Game.Implication.implication
msgid "Implication World"
msgstr ""

#: Game.Induction.Tutorial
msgid "2 + 2 = 4"
msgstr ""

#: Game.Induction.Tutorial
msgid "a + 0 = a"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#: Game.Implication.predecessor
msgid "0 โ succ(n)"
msgstr ""

#: Game.Induction.Tutorial
msgid "rewrite Tutorial"
msgstr ""

#: Game.Induction.Exponentiation
msgid "a ^ (m + n) = a ^ m * a ^ n"
msgstr ""

#: Game.Induction.Addition
#: Game.Induction.Addition
msgid "(a + b) + ั = (a + c) + b"
msgstr ""

#: Game.Induction.Multiplication
msgid "Left-commutativity of multiplication"
msgstr ""

#. ยง0: ` b โ zero โ (pred b).succ = b`
#. ยง1: `cases' a with b`
#. ยง2: `zero`
#. ยง3: `succ b`
#: Game.Implication.predecessor
msgid "In this world, we prove the remaining two Peano axioms (yes, you heard that right!)\n"
"in Lean. Firs, we define the 'pred' function as\n"
"\n"
"def pred : โ โ โ\n"
"\n"
"  | zero => zero\n"
"\n"
"  | succ a => a\n"
"\n"
"and start with two theorems 'pred_zero_eq_zero', and 'pred_succ_eq_self'.\n"
"\n"
"Curiously enough, you can prove this level by induction! But in this case, you really don't need the induction assumption ยง0.\n"
"In such cases, you can use ยง1 command instead of induction. This leaves you\n"
"with two goals: prove your statement for ยง2 and for ยง3."
msgstr ""

#: Game.Induction.Multiplication
msgid "succ(a) * b = a * b + b"
msgstr ""

#: Game.Induction.Exponentiation
msgid "1 ^ a = 1"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P โ Q`
#. ยง2: `apply`
#. ยง3: `Q`
#. ยง4: `h : P โ Q`
#. ยง5: `apply h`
#. ยง6: `P`
#. ยง7: `h1 : P`
#. ยง8: `h2 : P โ Q`
#. ยง9: `apply h2 at h1`
#. ยง10: `h1`
#. ยง11: `Q`
#. ยง12: `h1 : P`
#. ยง13: `h2 : P โ Q`
#. ยง14: `h2 h1`
#. ยง15: `Q`
#. ยง16: `h2 : P โ Q`
#. ยง17: `P`
#. ยง18: `Q`
#. ยง19: `h1 : P`
#. ยง20: `P`
#. ยง21: `h2 : P โ Q`
#. ยง22: `P`
#. ยง23: `Q`
#. ยง24: `h2 h1`
#. ยง25: `Q`
#: Game.Implication.implication
msgid "Lean denotes the statement 'If P, then Q' by ยง0. You can type โ by using the  shortcut.\n"
"To use an assumption of the form ยง1, you can use the ยง2 command. This command has\n"
"two modes:\n"
"\n"
"First, if your goal is ยง3, and ยง4 is known, you can type ยง5, which will change\n"
"your goal to ยง6.\n"
"\n"
"Second, if ยง7 and ยง8 are assumptions, you can type ยง9 to\n"
"change the assumption ยง10 to ยง11.\n"
"\n"
"There's also a third way to apply statements, which is the shortest, but also the hardest to read.\n"
"If ยง12 and ยง13 are any statements, you can use ยง14 to get the statement ยง15.\n"
"That is, ยง16 can be intepreted as a function from proofs of ยง17 to proofs of ยง18.\n"
"If ยง19 is a proof of ยง20, and ยง21 is a function from proofs of ยง22 to proofs of ยง23,\n"
"then, naturally, ยง24 is a proof of ยง25."
msgstr ""

#: Game.Induction.Tutorial
msgid "Two plus two is four"
msgstr ""

#: Game.Induction.Multiplication
msgid "Commutativity of Multiplication"
msgstr ""

#: Game
msgid "Stepan's Lean Game"
msgstr ""

#: Game.Induction.Addition
msgid "Left-associativity of Addition"
msgstr ""

#: Game.Induction.Addition
msgid "Commutativity of Addition"
msgstr ""

#: Game.Induction.Multiplication
msgid "Multiplication by one from the left"
msgstr ""

#: Game.Induction.Multiplication
msgid "1 * a = a"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#: Game.Induction.Tutorial
msgid "This is a tutorial world introducing basic Lean tactics."
msgstr ""

#. ยง0: `at`
#. ยง1: `rw [zero_add] at h`
#. ยง2: `something + zero`
#: Game.Implication.implication
msgid "You can do rewriting inside you assumtion by using the ยง0 keyword. Type ยง1\n"
"to instruct Lean to find the pattern ยง2 inside the assumption h."
msgstr ""

#: Game.Induction.Exponentiation
msgid "(a * b) ^ n = a ^ n * b ^ n"
msgstr ""

#. ยง0: `symm`
#. ยง1: `A = B`
#. ยง2: `B = A`
#. ยง3: `symm`
#. ยง4: `symm at h`
#: Game.Implication.implication
msgid "You can use the ยง0 command to flip statements from ยง1 to ยง2. Type ยง3\n"
"to do this to the goal, or ยง4 to do this at the assumption h."
msgstr ""

#: Game.Induction.Multiplication
msgid "a * 2 = a + a"
msgstr ""

#. ยง0: `mul_zero`
#. ยง1: `mul_succ`
#: Game.Induction.Multiplication
msgid "Multiplication on the natural numbers is defined by\n"
" def mul : โ โ โ โ โ\n"
"   | _, zero => zero\n"
"   | a, succ b => add (mul a b) a\n"
"Therfore, theorems ยง0 and ยง1 are true by definition."
msgstr ""

#: Game.Induction.Addition
msgid "Adding zero from the left"
msgstr ""

#: Game.Implication.predecessor
msgid "In this level, we define a function is_zero by\n"
"\n"
"def is_zero : โ โ Prop\n"
"\n"
"  | zero => True\n"
"\n"
"  | succ _ => False\n"
"\n"
"We have two new theorems 'is_zero_zero' and 'not_is_zero_of_succ'."
msgstr ""

#: Game.Induction.Exponentiation
msgid "Exponentiation World"
msgstr ""

#: Game.Induction.Addition
#: Game.Induction.Addition
msgid "a + b = b + a"
msgstr ""

#: Game.Implication.predecessor
msgid "pred(succ(a))=a"
msgstr ""

#: Game.Induction.Tutorial
msgid "Rewriting theorems"
msgstr ""

#: Game.Induction.Multiplication
#: Game.Induction.Multiplication
msgid "Multiplication by two from the right"
msgstr ""

#: Game.Implication.Cancellation
msgid "Cancellation World"
msgstr ""

#: Game.Implication.predecessor
msgid "1 โ 0"
msgstr ""

#: Game
msgid "This is my draft of the Lean game which extends the natural number game up to\n"
"proving the Fundamental Theorem of Arithmetic."
msgstr ""

#: Game.Induction.Exponentiation
msgid "a ^ 0 = 1"
msgstr ""

#: Game.Induction.Multiplication
msgid "a * 0 = 0"
msgstr ""

#: Game.Implication.predecessor
msgid "pred(0)=0"
msgstr ""

#: Game.Induction.Multiplication
msgid "(a * b) * c = a * (b * c)"
msgstr ""

#: Game.Induction.Multiplication
msgid "Multiplication by zero from the left"
msgstr ""

#: Game.Induction.Multiplication
msgid "Multiplication World"
msgstr ""

#: Game.Implication.predecessor
msgid "succ n โ 0"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#: Game.Induction.Addition
msgid "Adding successor from the left"
msgstr ""

#: Game.Induction.Multiplication
msgid "Multiplication by the successor from the left"
msgstr ""

#: Game.Induction.Multiplication
msgid "Associativity of multiplication"
msgstr ""

#: Game.Induction.Multiplication
msgid "Multiplication by one from the right"
msgstr ""

#: Game.Induction.Tutorial
msgid "Tutorial"
msgstr ""

#: Game.Induction.Exponentiation
msgid "a ^ (succ(b)) = a ^ b * a"
msgstr ""

#. ยง0: `h : A = B`
#. ยง1: `rewrite [h]`
#. ยง2: `rewrite [h]`
#. ยง3: `y`
#. ยง4: `x + three`
#: Game.Induction.Tutorial
msgid "To use an assumption of the form ยง0, you can use the ยง1 command.\n"
"In the example below, typing ยง2 will change ยง3 to ยง4 in the goal."
msgstr ""

#: Game.Induction.Addition
msgid "Addition World"
msgstr ""

#: Game.Induction.Multiplication
msgid "Right distributivity of multiplication"
msgstr ""

#: Game.Induction.Multiplication
msgid "a * succ(b) = a * b + a"
msgstr ""

#. ยง0: `rewrite [h : A = B]`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `nth_rewrite 1 [h]`
#. ยง6: `nth_rewrite 2 [h]`
#: Game.Induction.Tutorial
msgid "The ยง0 command instructs Lean to change **all** instances of ยง1 in the\n"
"goal to ยง2. If you have two instances of ยง3, and would like to change only one of them to\n"
"ยง4, you can instruct Lean to do so by typing either ยง5 or ยง6."
msgstr ""

#. ยง0: `add_zero`
#. ยง1: `rewrite [add_zero]`
#. ยง2: `something + zero`
#. ยง3: `something`
#. ยง4: `add_zero`
#. ยง5: `add_zero c`
#. ยง6: `c + zero = zero`
#. ยง7: `rewrite [add_zero c]`
#. ยง8: `c + zero`
#. ยง9: `c`
#: Game.Induction.Tutorial
msgid "This is our first theorem, ยง0. A theorem is like an assumption that is always\n"
"available. If you type ยง1, Lean will find the first instance of\n"
"the expression ยง2 in the goal and change it to ยง3.\n"
"You can also instruct Lean to rewrite the specific instance of ยง4 which you want.\n"
"For example, ยง5 is the name for the equality ยง6. Typing\n"
"ยง7 will instruct Lean to find specifically the expression ยง8\n"
"and change it to ยง9."
msgstr ""

#: Game.Induction.Addition
msgid "Associativity of Addition"
msgstr ""

#: Game.Induction.Tutorial
msgid "rfl Tutorial"
msgstr ""

#: Game.Induction.Multiplication
msgid "(a + b) * c = a * c + b * c"
msgstr ""

#: Game.Induction.Exponentiation
msgid "a ^ 2 = a * a"
msgstr ""

#: Game.Implication.predecessor
msgid "ยฌ is_zero (succ n)"
msgstr ""

#: Game.Induction.Tutorial
msgid "Rewriting definitions"
msgstr ""

#: Game.Induction.Exponentiation
msgid "a ^ 1 = a"
msgstr ""

#. ยง0: `one`
#. ยง1: `succ zero`
#. ยง2: `two`
#. ยง3: `succ one`
#. ยง4: `rewrite [two]`
#. ยง5: `two`
#. ยง6: `succ one`
#. ยง7: `rewrite [โ h]`
#. ยง8: `โ`
#: Game.Induction.Tutorial
msgid "In our game, ยง0 is defined as ยง1, and ยง2 is defined\n"
"as ยง3. You can type ยง4 to change ยง5 to ยง6 in the goal.\n"
"To rewrite backwards, you need to type ยง7. To type ยง8, use the \\\\l shortcut.\n"
"For example, `rewrite [โ one] also works."
msgstr ""

#: Game.Induction.Multiplication
msgid "(a * b) * c = (a * c) * b"
msgstr ""

#: Game.Induction.Multiplication
msgid "a * b = b * a"
msgstr ""

#: Game.Induction.Addition
msgid "succ(a) + b = succ(a + b)"
msgstr ""

#. ยง0: `induction' a with d hd`
#. ยง1: `a`
#. ยง2: `zero + zero = zero`
#. ยง3: `d : โ`
#. ยง4: `hd : zero + d = d`
#. ยง5: `โข zero + d.succ = d.succ`
#. ยง6: `d`
#. ยง7: `hd`
#. ยง8: `rw [h]`
#. ยง9: `rewrite [h]`
#. ยง10: `rw`
#. ยง11: `rewrite`
#. ยง12: `rw`
#. ยง13: `rfl`
#: Game.Induction.Addition
msgid "To prove this next theorem, you need to use induction. This is done by using the command\n"
"ยง0, where ยง1 is the variable you want to do induction on. This\n"
"creates two subgoals:\n"
"Goal 1: ยง2 -- prove the base case of the induction.\n"
"Goal 2 : ยง3\n"
"          ยง4\n"
"          ยง5 -- prove the induction step.\n"
"As you can see, ยง6 and ยง7 are just arbitrary names you give to the variable in the\n"
"induction step and the induction assumption.\n"
"\n"
"You can also use ยง8 instead of ยง9. ยง10 is the better version of ยง11\n"
"in that ยง12 tries to apply ยง13 automatically after rewriting. This makes the code shorter."
msgstr ""

#: Game.Induction.Exponentiation
msgid "0 ^ (succ(m)) = 0"
msgstr ""

#: Game.Implication.predecessor
msgid "0 โ 1"
msgstr ""

#: Game.Induction.Exponentiation
msgid "Exponentiation on the natural numbers is defined by\n"
"def pow : โ โ โ โ โ\n"
"  | _, zero => one\n"
"  | a, succ b => mul (pow a b) a\n"
" Hence, we also start with two results which are true by definition."
msgstr ""

#: Game.Induction.Exponentiation
msgid "a ^ (m * n) = (a ^ m) ^ n"
msgstr ""

#: Game.Induction.Multiplication
msgid "a * (b * c) = b * (a * c)"
msgstr ""

#: Game.Induction.Multiplication
msgid "a * 1 = a"
msgstr ""

#. ยง0: `have`
#. ยง1: `have h : P := by`
#. ยง2: `h : P`
#. ยง3: `apply h`
#: Game.Implication.implication
msgid "If you want to prove a statement as an intermediate step, you can use the ยง0 command.\n"
"Type ยง1 and indent the code to the right to temporarily change your goal\n"
"to P. After you finish the proof, ยง2 will be added to the list of your assumptions.\n"
"\n"
"You can also just use ยง3 in this situation, which will leave you with two hanging goals."
msgstr ""

#: Game.Induction.Tutorial
msgid "succ a = a + 1"
msgstr ""

#: Game.Induction.Exponentiation
msgid "(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2"
msgstr ""

#: Game.Induction.Multiplication
msgid "0 * a = 0"
msgstr ""

#: Game.Induction.Addition
msgid "Right-associativity of Addition"
msgstr ""

#: Game.Implication.predecessor
msgid "If a โ 0, then succ(pred(a))=a"
msgstr ""

#: Game.Implication.predecessor
msgid "Predecessor World"
msgstr ""

#: Game.Induction.Multiplication
msgid "2 * a = a + a"
msgstr ""

#. ยง0: `A = A`
#. ยง1: `rfl`
#. ยง2: `rfl`
#: Game.Induction.Tutorial
msgid "To prove the goal of the form ยง0, you need to use the ยง1 command. Type ยง2\n"
"in the example below to close the goal."
msgstr ""

#: Game.Induction.Tutorial
msgid "Adding one"
msgstr ""

#: Game.Induction.Multiplication
msgid "Left distributiviy of multiplication"
msgstr ""
